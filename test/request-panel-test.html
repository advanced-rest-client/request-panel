<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>request-panel test</title>
  <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <link rel="import" href="../request-panel.html">
</head>

<body>
  <test-fixture id="Basic">
    <template>
      <request-panel></request-panel>
    </template>
  </test-fixture>
  <script>
  suite('request-panel', () => {
    function appendRequestData(element, request) {
      request = request || {};
      const editor = element.shadowRoot.querySelector('request-editor');
      editor.httpMethod = request.method || 'get';
      editor.url = request.url || 'https://domain.com';
      editor.headers = request.headers || '';
      editor.payload = request.payload;
    }
    suite('Initialization', () => {
      test('responseMeta is not computed', () => {
        const element = fixture('Basic');
        assert.isUndefined(element.responseMeta);
      });

      test('hasResponse is undefined', () => {
        const element = fixture('Basic');
        assert.isUndefined(element.hasResponse);
      });

      test('api-request is dispatched', (done) => {
        const element = fixture('Basic');
        flush(() => {
          appendRequestData(element);
          element.addEventListener('api-request', () => {
            done();
          });
          const editor = element.shadowRoot.querySelector('request-editor');
          editor.send();
        });
      });
    });

    suite('send()', () => {
      let element;
      setup((done) => {
        element = fixture('Basic');
        element.request = {
          url: 'https://domain.com/',
          method: 'GET',
          headers: 'accept: text/plain'
        };
        flush(() => done());
      });

      test('Calls send() on the editor', () => {
        const node = element.shadowRoot.querySelector('request-editor');
        const spy = sinon.spy(node, 'send');
        element.send();
        assert.isTrue(spy.called);
      });
    });

    suite('abort()', () => {
      let element;
      setup((done) => {
        element = fixture('Basic');
        element.request = {
          url: 'https://domain.com/',
          method: 'GET',
          headers: 'accept: text/plain'
        };
        flush(() => done());
      });

      test('Calls abort() on the editor', () => {
        const node = element.shadowRoot.querySelector('request-editor');
        const spy = sinon.spy(node, 'abort');
        element.abort();
        assert.isTrue(spy.called);
      });
    });

    suite('clear()', () => {
      let element;
      setup((done) => {
        element = fixture('Basic');
        element.request = {
          url: 'https://domain.com/',
          method: 'GET',
          headers: 'accept: text/plain'
        };
        flush(() => done());
      });

      test('Calls clearRequest() on the editor', () => {
        const node = element.shadowRoot.querySelector('request-editor');
        const spy = sinon.spy(node, 'clearRequest');
        element.clear();
        assert.isTrue(spy.called);
      });
    });

    suite('_abortHandler()', () => {
      let element;
      setup((done) => {
        element = fixture('Basic');
        element.lastRequestId = 'test-id';
        element.loading = true;
        flush(() => done());
      });

      test('Clears lastRequestId', () => {
        element._abortHandler();
        assert.isUndefined(element.lastRequestId);
      });

      test('Clears loading', () => {
        element._abortHandler();
        assert.isFalse(element.loading);
      });

      test('Calls _abortHandler from the event', () => {
        const editor = element.shadowRoot.querySelector('request-editor');
        editor.dispatchEvent(new CustomEvent('abort-api-request', {
          bubbles: true,
          composed: true
        }));
        assert.isUndefined(element.lastRequestId);
        assert.isFalse(element.loading);
      });
    });

    suite('_clearHandler()', () => {
      let element;
      setup((done) => {
        element = fixture('Basic');
        element.lastRequestId = 'test-id';
        element.loading = true;
        flush(() => done());
      });

      test('Clears lastRequestId', () => {
        element._clearHandler();
        assert.isUndefined(element.lastRequestId);
      });

      test('Clears loading', () => {
        element._clearHandler();
        assert.isFalse(element.loading);
      });

      test('Calls _clearHandler from the event', () => {
        const editor = element.shadowRoot.querySelector('request-editor');
        editor.dispatchEvent(new CustomEvent('request-clear-state', {
          bubbles: true,
          composed: true
        }));
        assert.isUndefined(element.lastRequestId);
        assert.isFalse(element.loading);
      });
    });

    suite('_apiResponseHandler()', () => {
      function fire() {
        const detail = {
          id: 'test-id',
          request: {
            url: 'https://domain.com/',
            method: 'GET',
            headers: 'accept: text/plain'
          },
          response: {
            status: 200,
            statusText: 'OK',
            payload: 'Hello world',
            headers: 'content-type: text/plain'
          },
          loadingTime: 124.12345678,
          isError: false,
          isXhr: true
        };
        const e = new CustomEvent('api-response', {
          bubbles: true,
          detail
        });
        document.body.dispatchEvent(e);
      }
      let element;
      setup((done) => {
        element = fixture('Basic');
        element.lastRequestId = 'test-id';
        element.loading = true;
        flush(() => done());
      });

      test('Ignores event when different id', () => {
        element.lastRequestId = 'other-id';
        fire();
        assert.isTrue(element.loading);
      });

      test('Clears loading', () => {
        fire();
        assert.isFalse(element.loading);
      });

      test('Propagates the response', () => {
        fire();
        assert.isTrue(element.hasResponse);
        assert.typeOf(element.responseMeta, 'object');
      });
    });

    suite('_changeUrlHandler()', () => {
      function fire(element) {
        const e = new CustomEvent('url-change-action', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            url: 'http://test.com'
          }
        });
        element.dispatchEvent(e);
        return e;
      }
      let element;
      setup((done) => {
        element = fixture('Basic');
        flush(() => done());
      });

      test('Sets new URL', () => {
        const e = fire(element);
        assert.equal(element.editorRequest.url, e.detail.url);
      });

      test('Event is cancelled', () => {
        const e = fire(element);
        assert.isTrue(e.defaultPrevented);
      });
    });

    suite('_boundEventsChanged()', () => {
      let element;
      setup((done) => {
        element = fixture('Basic');
        flush(() => done());
      });

      test('Does nothing when argument is false', () => {
        const old = element.eventsTarget;
        element._boundEventsChanged(false);
        assert.isTrue(element.eventsTarget === old);
      });

      test('Sets self as event target when argument is true', () => {
        element._boundEventsChanged(true);
        assert.isTrue(element.eventsTarget === element);
      });
    });

    suite('XHR response handling', () => {
      function propagate(element) {
        const detail = {
          request: {
            url: 'https://domain.com/',
            method: 'GET',
            headers: 'accept: text/plain'
          },
          response: {
            status: 200,
            statusText: 'OK',
            payload: 'Hello world',
            headers: 'content-type: text/plain'
          },
          loadingTime: 124.12345678,
          isError: false,
          isXhr: true
        };
        element._propagateResponse(detail);
      }

      let element;
      setup((done) => {
        element = fixture('Basic');
        flush(() => done());
      });

      test('hasResponse is set', () => {
        propagate(element);
        assert.isTrue(element.hasResponse);
      });

      test('responseMeta is set', () => {
        propagate(element);
        assert.typeOf(element.responseMeta, 'object');
      });

      test('isErrorResponse is false', () => {
        propagate(element);
        assert.isFalse(element.isErrorResponse);
      });

      test('responseError is undefined', () => {
        propagate(element);
        assert.isUndefined(element.responseError, 'error is undefined');
      });

      test('request is set', () => {
        propagate(element);
        assert.typeOf(element.request, 'object');
      });

      test('response is set', () => {
        propagate(element);
        assert.typeOf(element.response, 'object');
      });

      test('loadingTime is set', () => {
        propagate(element);
        assert.equal(element.responseMeta.loadingTime, 124.12345678);
      });

      test('responseIsXhr is true', () => {
        propagate(element);
        assert.isTrue(element.responseMeta.responseIsXhr);
      });

      test('redirects is undefined', () => {
        propagate(element);
        assert.isUndefined(element.responseMeta.redirects);
      });

      test('redirectsTiming is undefined', () => {
        propagate(element);
        assert.isUndefined(element.responseMeta.redirectsTiming, 'array');
      });

      test('timing is undefined', () => {
        propagate(element);
        assert.isUndefined(element.responseMeta.timing, 'object');
      });

      test('source message is undefined', () => {
        propagate(element);
        assert.isUndefined(element.responseMeta.sourceMessage, 'string');
      });
    });

    suite('Advanced response handling', () => {
      function propagate(element) {
        let headers = 'content-type: text/plain\nlocation: ';
        headers += 'https://other.domain.com\ncontent-length: 30';
        const detail = {
          request: {
            url: 'https://domain.com/',
            method: 'GET',
            headers: 'accept: text/plain'
          },
          response: {
            status: 200,
            statusText: 'OK',
            payload: 'Hello world',
            headers: 'content-type: text/plain'
          },
          loadingTime: 124.12345678,
          isError: false,
          isXhr: false,
          sentHttpMessage: 'GET / HTTP/1.1\nHost: domain.com\naccept: text/plain\n\n\n',
          redirects: [{
            status: 301,
            statusText: 'Not here',
            payload: 'Go to https://other.domain.com',
            headers: headers
          }],
          timing: {
            blocked: 12.0547856,
            dns: 0.12,
            connect: 112.21458762,
            send: 4.4748989,
            wait: 15.8436988,
            receive: 65.125412256,
            ssl: 10
          },
          redirectsTiming: [{
            blocked: 12.0547856,
            dns: 0.12,
            connect: 112.21458762,
            send: 4.4748989,
            wait: 15.8436988,
            receive: 65.125412256,
            ssl: 10
          }]
        };
        element._propagateResponse(detail);
      }
      let element;
      setup((done) => {
        element = fixture('Basic');
        flush(() => done());
      });

      test('hasResponse is set', () => {
        propagate(element);
        assert.isTrue(element.hasResponse);
      });

      test('responseMeta is set', () => {
        propagate(element);
        assert.typeOf(element.responseMeta, 'object');
      });

      test('isErrorResponse is false', () => {
        propagate(element);
        assert.isFalse(element.isErrorResponse);
      });

      test('responseError is undefined', () => {
        propagate(element);
        assert.isUndefined(element.responseError, 'error is undefined');
      });

      test('request is set', () => {
        propagate(element);
        assert.typeOf(element.request, 'object');
      });

      test('response is set', () => {
        propagate(element);
        assert.typeOf(element.response, 'object');
      });

      test('loadingTime is set', () => {
        propagate(element);
        assert.equal(element.responseMeta.loadingTime, 124.12345678);
      });

      test('responseIsXhr is false', () => {
        propagate(element);
        assert.isFalse(element.responseMeta.responseIsXhr);
      });

      test('redirects is set', () => {
        propagate(element);
        assert.typeOf(element.responseMeta.redirects, 'array');
      });

      test('redirectsTiming is set', () => {
        propagate(element);
        assert.typeOf(element.responseMeta.redirectsTiming, 'array');
      });

      test('timing is set', () => {
        propagate(element);
        assert.typeOf(element.responseMeta.timing, 'object');
      });

      test('source message is set', () => {
        propagate(element);
        assert.typeOf(element.responseMeta.sourceMessage, 'string');
      });

      test('Calling clearResponse() clears response', () => {
        propagate(element);
        element.clearResponse();
        assert.isUndefined(element.isErrorResponse);
        assert.isUndefined(element.responseError);
        assert.isUndefined(element.request);
        assert.isUndefined(element.response);
        assert.deepEqual(element.responseMeta, {});
      });
    });

    suite('Response error handling', () => {
      function propagate(element) {
        const detail = {
          request: {
            url: 'https://domain.com/',
            method: 'GET',
            headers: 'accept: text/plain'
          },
          response: {
            status: 0,
            statusText: 'NOT OK',
            payload: 'Hello world',
            headers: 'content-type: text/plain'
          },
          loadingTime: 124.12345678,
          isError: true,
          error: new Error('test-error'),
          isXhr: true
        };
        element._propagateResponse(detail);
      }

      let element;
      setup((done) => {
        element = fixture('Basic');
        flush(() => done());
      });

      test('hasResponse is set', () => {
        propagate(element);
        assert.isTrue(element.hasResponse);
      });

      test('responseMeta is set', () => {
        propagate(element);
        assert.typeOf(element.responseMeta, 'object');
      });

      test('isErrorResponse is true', () => {
        propagate(element);
        assert.isTrue(element.isErrorResponse);
      });

      test('responseError is set', () => {
        propagate(element);
        assert.typeOf(element.responseError, 'error');
      });

      test('request is set', () => {
        propagate(element);
        assert.typeOf(element.request, 'object');
      });

      test('response is set', () => {
        propagate(element);
        assert.typeOf(element.response, 'object');
      });

      test('loadingTime is set', () => {
        propagate(element);
        assert.equal(element.responseMeta.loadingTime, 124.12345678);
      });

      test('responseIsXhr is true', () => {
        propagate(element);
        assert.isTrue(element.responseMeta.responseIsXhr);
      });
    });
  });
  </script>
</body>

</html>
