<!--
@license
Copyright 2017 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../events-target-behavior/events-target-behavior.html">
<link rel="import" href="../variables-evaluator/variables-evaluator.html">
<link rel="import" href="../uuid-generator/uuid-generator.html">

<script>
Polymer({
  is: 'request-logic',
  behaviors: [ArcBehaviors.EventsTargetBehavior],

  properties: {
    /**
     * The request object with current request editor state.
     * It contains the following properties:
     * - headers {String}
     * - method {String}
     * - url {String}
     * - payload {String|FormData|File}
     *
     * To listen for a change to this object use `request-data-changed`
     * custom ebent fired from the `request-editor` element.
     */
    request: Object,
    /**
     * Number of milliseconds after which the `before-request` event handlers
     * will be cancelled and the request continue without waiting for the
     * result. When set to `0`, `null`, `undefined` or `false` the timeoout
     * is not applied and the element waits with the request until
     * `continue-request` event is fired.
     */
    handlersTimeout: {
      type: Number,
      value: 2000
    },
    /**
     * Computed value. If true then the request is loading.
     * This resets each time the request status changes.
     */
    loading: {
      type: Boolean,
      notify: true
    },
    /**
     * Current before-request handlers timeout ID
     */
    _currentTimeout: Number,
    /**
     * If set the element listens for the `continue-request` event and
     * sends the request if it wasn't already.
     */
    _awaitingContinue: Boolean,
    /**
     * Set to `true` if the cancel request event has been fired.
     */
    _cancelled: Boolean,
    /**
     * Set to true if current request has timed out in the `before-request`
     * event handlers. The request will continue without without waiting for
     * the event handlers anymore.
     */
    beforeTimedOut: {
      type: Boolean,
      readOnly: true
    },
    // Generated last request ID when sending the request.
    lastRequestId: {
      type: String,
      notify: true,
      readOnly: true
    }
  },

  _attachListeners: function(node) {
    this.listen(node, 'continue-request', 'continueRequest');
    this.listen(node, 'resend-auth-request', '_resend');
  },

  _detachListeners: function(node) {
    this.unlisten(node, 'continue-request', 'continueRequest');
    this.unlisten(node, 'resend-auth-request', '_resend');
  },

  get _evalElement() {
    if (!this.$) {
      this.$ = {};
    }
    if (!this.$.eval) {
      this.$.eval = document.createElement('variables-evaluator');
      this.$.eval.noBeforeRequest = true;
      this.$.eval.eventTarget = this.eventsTarget;
      Polymer.dom(this.root).appendChild(this.$.eval);
    }
    return this.$.eval;
  },

  get _uuid() {
    if (!this.$) {
      this.$ = {};
    }
    if (!this.$.uuid) {
      this.$.uuid = document.createElement('uuid-generator');
    }
    return this.$.uuid;
  },

  reset: function() {
    this._awaitingContinue = false;
    this._beforePromisesResolved = true;
    this._requestCopy = undefined;
    this._cancelled = false;
    this.loading = false;
    this._setBeforeTimedOut(false);
  },

  /**
   * Sends current request
   * @return {Promise} A promise resolved when the `before-request` custom
   * event is dispatched.
   */
  send: function() {
    var request = this._prepareEventRequest();
    return this._beforeProcessVariables(request);
  },

  cancel: function() {
    this._cancelled = true;
  },
  /**
   * Prepares a request object to be used to send it with the `before-request`
   * event. This is a "shallow" copy of the `request` property. It only creates
   * a copy of the primitive values of the object. If the `payload` is an
   * object (`FormData` or `File`) then it will be passed by reference instead
   * of copying the object.
   *
   * It adds `promises` property to the object that is required by the
   * `before-request` event.
   *
   * @return {Object} Copy of the `request` property.
   */
  _prepareEventRequest: function() {
    var request = this.request;
    var shallowCopy = Object.assign({}, request);
    shallowCopy.id = this._uuid.generate();
    this._setLastRequestId(shallowCopy.id);
    shallowCopy.promises = [];
    if (['GET', 'HEAD'].indexOf(request.method) !== -1) {
      delete shallowCopy.payload;
    }
    return shallowCopy;
  },

  /**
   * Before the request object can be sent to any `before-request` handler
   * it must be first evaluated by variables evaluator. It is the only way to
   * ensure that the handler will receive actuall request data.
   */
  _beforeProcessVariables: function(request) {
    return new Promise((resolve, reject) => {
      this._evalElement.cache = undefined;
      this._evalElement.context = undefined;
      this._evalElement._processBeforeRequest(request, resolve, reject);
    })
    .then(request => {
      this._beforeRequest(request);
    })
    .catch(() => {
      this._beforeRequest(request);
    });
  },

  /**
   * Handles the before request logic.
   * @param {Object} request The request object.
   */
  _beforeRequest: function(request) {
    this.reset();
    this.loading = true;
    var event = this.fire('before-request', request, {
      cancelable: true,
      composed: true
    });
    if (event.defaultPrevented) {
      return this._reportCancelation(event.detail.reason);
    }
    this._requestCopy = request;
    var p = event.detail.promises;
    if (p && p.length) {
      this._beforePromisesResolved = false;
      let timeout = this._computeHandlersTimeout(p);
      p = Promise.all(p);
      if (timeout > 0) {
        this._currentTimeout =
          window.setTimeout(this._onBeforeRequestTimeout.bind(this), timeout);
      } else {
        this._awaitingContinue = true;
      }
    } else {
      p = Promise.resolve();
    }
    p.then(() => {
      this._beforePromisesResolved = true;
      if (this.beforeTimedOut || this._cancelled) {
        return;
      }
      if (!this._awaitingContinue) {
        this._continueRequest(request);
      }
    })
    .catch(cause => {
      this.loading = false;
      this._reportError(cause);
      console.warn(cause);
    });
  },

  /**
   * Opens the cancelation message toast
   * @param {?String} reason Message to display. Optional.
   */
  _reportCancelation: function(reason) {
    this.loading = false;
    this.fire('request-cancelled', {
      message: reason || 'The request has been canceled'
    }, {
      bubbles: false
    });
  },

  _reportError: function(cause) {
    this.loading = false;
    this._clearBeforeRequestTimeout();
    var message = cause && cause.message ? cause.message : 'An error occurred';
    this.fire('request-error', {
      message: message
    }, {
      bubbles: false
    });
  },

  /**
   * Computes timeout for the before-request event handlers.
   * It reads a `timeout` property from a promise. If set, it returns a highest
   * value for the timeout or default value defined in the `handlersTimeout`
   * property. If `handlersTimeout` is falsy or any timeout property equals
   * zero (`0`) then this function returns -1 meaning no timeout.
   *
   * @param {Array} promises Array of promises returned by the handlers.
   * @return {Number} -1 for no timeout or positive number of milliseconds
   * for the `before-request` event to be handled by all handlers.
   */
  _computeHandlersTimeout: function(promises) {
    var timeout = this.handlersTimeout;
    if (!timeout) {
      return -1;
    }
    if (!promises || !promises.length) {
      return timeout;
    }
    for (var i = 0, len = promises.length; i < len; i++) {
      if (promises[i].timeout !== undefined) {
        if (promises[i].timeout === 0) {
          return -1;
        }
        if (promises[i].timeout > timeout) {
          timeout = promises[i].timeout;
        }
      }
    }
    if (timeout === 0) {
      timeout = -1;
    }
    return timeout;
  },
  /**
   * Clears the before-request timeout timer.
   */
  _clearBeforeRequestTimeout: function() {
    if (this._currentTimeout) {
      window.clearTimeout(this._currentTimeout);
      this._currentTimeout = undefined;
    }
  },
  /**
   * Called when the `before-request` timeout fired.
   * It continues the request with current values in the `_requestCopy`
   * property that has been sent with the `before-request` event.
   */
  _onBeforeRequestTimeout: function() {
    this._currentTimeout = undefined;
    this._setBeforeTimedOut(true);
    console.warn('The before-request event handlers timed out.');
    this._continueRequest(this._requestCopy);
  },
  /**
   * A handler for the `continue-request` custom event. It can be called
   * manually too.
   *
   * If "continues" the request if all promises for the `before-request`
   * has been resolved.
   * It do nothing if current request doesn't expect this event to be handled
   * (no timeout set to 0).
   */
  continueRequest: function() {
    if (!this._awaitingContinue) {
      return;
    }
    if (!this._beforePromisesResolved) {
      this._awaitingContinue = false;
      return;
    }
    this._continueRequest(this._requestCopy);
  },
  /**
   * Called when before request block finished (whatever the output) and the
   * request can now be send to the transport library.
   *
   * @param {Object} request The request object
   */
  _continueRequest: function(request) {
    this._requestCopy = undefined;
    this._clearBeforeRequestTimeout();
    delete request.promises;
    delete request.reason;
    // Changes to the `_requestCopy` object won't affect sent object.
    // However changes made to FormData or File object of the payload property
    // or to the `auth` object will affect send object because those are
    // references to an object.
    var copy = this._prepareTransportObject(request);
    this.fire('transport-request', copy);
  },

  /**
   * Creates an immutable request data object to be send to the transport
   * library.
   * @return {Object} Immutable request object.
   */
  _prepareTransportObject: function(request) {
    var configuration = {};
    Object.keys(request).forEach(key => {
      configuration[key] = {
        value: request[key],
        writable: false,
        enumerable: true
      };
    });
    return Object.create(Object.prototype, configuration);
  },

  // Handler for the `resend-auth-request` event. Sends this request.
  _resend: function(e) {
    if (e.detail.id !== this.lastRequestId) {
      return;
    }
    this.send();
  }
});
</script>
