<!--
@license
Copyright 2017 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../arc-status-bar/arc-status-bar.html">
<link rel="import" href="../request-editor/request-editor.html">
<link rel="import" href="../response-view/response-view.html">
<link rel="import" href="../paper-toast/paper-toast.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../iron-scroll-target-behavior/iron-scroll-target-behavior.html">
<link rel="import" href="../events-target-behavior/events-target-behavior.html">
<link rel="import" href="../paper-progress/paper-progress.html">
<link rel="import" href="../uuid-generator/uuid-generator.html">
<link rel="import" href="../variables-evaluator/variables-evaluator.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../arc-icons/arc-icons.html">
<link rel="import" href="../paper-tooltip/paper-tooltip.html">

<!--
A full request and response view for the Advanced REST client

# Example

```
<request-panel handlers-timeout="2000"></request-panel>
```

Note: This element internally uses `variables-evaluator` element but it doesn't
use `variables-manager` and it soulf be included into the app if variables should
be evaluated correctly.

## Request lifecycle

Detailed description: <https://github.com/jarrodek/ChromeRestClient/issues/1010>

### before-request event

Before sending a request the `before-request` custom event is fired. The event contains the `promises` array on the detail object where all promises should be kept. Handlers can modify any part of the request message.

This event is cancellable. If the event has been cancelled by any of the listeners then the request fails. Handlers may set a reason property on the event's detail object to display a reason to the user.

The handler have a timeout set from the `handlers-timeout` attribute of the element to complete any scheduled tasks. If a handler requires more time to execute (eg. request debugger) it should set a `timeout` property on the Promise object. It is a non-normative property for this object but it will help control the workflow properly. The request will be fired after the number of milliseconds of the highest timeout value. If 0 is set then the request will be halted until `continue-request` event is fired.

The request data in the event are already evaluated by the `variables-evaluator`
element so handlers receive final request parameters.

#### Properties

The details object has following properties:

-   `url` (`string`)- Request URL.
-   `headers` (`string`) - Headers to be send.
-   `payload` (`string`) - Message body if the request can carry a body. GET and HEAD request will ignore this property.
-   `method` (`string`) - HTTP method.
-   `promises` (`array`) - An array where promises must be added
-   `reason` (`string`) - reason of cancelling the event.
-   `auth` (`object`) - an authorization data that will be passed to the transport library (`socket-fetch`)
-   `id` (`String`) - Request ID. It is an UUID for the request. The id is reported back by the transport library in all its events.

### transport-request

A non-cancelable, immutable request object.
This event is meant to be handled by the transport library that is attached to the DOM and handles the event.

#### Properties

The details object has following properties:

-   `url` (`string`)- Request URL.
-   `headers` (`String`) - Headers to be send.
-   `payload` (`String`) - Message body if the request can carry a body. GET and HEAD request will ignore this property.
-   `method` (`String`) - HTTP method.
-   `auth` (`Object`) - an authorization data that will be passed to the transport library (`socket-fetch`)
-   `id` (`String`) - Request ID. It is an UUID for the request. The id is reported back by the transport library in all its events.

### response-ready event

Event fired when the transport library finishes a request and both request and response object are ready.
Event is fired just before reporting the response to the user.  It can be cancelled but the response won't be presented to the user. The element that cancels the response should take an action that is visible to the user (eg, redirect, chain request etc). This event is synchronous so any async work on the response object won't be possible.

The request and response are Fetch's API `Request` and `Response` object. Body from both of the objects can be read only once so any handler that have to read the response / request body have to call `body.clone()` function that returns new `Body` object that can be read. If the handler use the body without cloning the object the response won't be reported to the user.

#### Properties

-   `request` (`Request`) - The request object as defined in the Fetch API spec.
-   `response` (`Response`) - The response object as defined in the Fetch API spec.
-   `isXhr` (`Boolean`) - If not set the element assumes it's true. Indicated if the transport method doesn't support advanced timings and redirects information.
-   `error` (`Error`) - When the request / response is errored (`request.ok` equals `false`) then the error object should be set with the human readable message that will be displayed to the user.
-   `loadingTime` (`Number`) - The response full loading time
-   `timings` (`Object`) - HAR 1.2 timings object
-   `redirect-timings` (`Array`) - Array of `timings` objects with timings of reach redirect. Elements in the array are ordered and each item corresponds to the one in `redirects` array
-   `redirects` (`Array`) - Array of `Response` objects. Elements in the array are ordered and each item corresponds to the one in `redirects-timings` array. Additionally the Response item should have a `requestUrl` property which corresponds to an URL to which the redirected request went to.
-   `sourceMessage` (`String`) - A source message that has been sent to the server.
-   `auth` (`Object`) - Returned by the transport library auth object

### headers-received event

Cancellable event fired by the transport library after headers has been received
from the server. All work must be done synchronously.
If the event is cancelled then the request is canceled. Handlers should take a
proper action action visible to the user (redirect, display UI).

#### Properties

-   `value` (`Headers`) Headers received from the server as a Fetch's [headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) object

### before-redirect event

Cancelable event fired by the transport library when a redirect about to occur.
All work must be done synchronously.
If the event is cancelled then the request is canceled. Handlers should take a
proper action action visible to the user (redirect, display UI).

### report-response

A non-cancelable, immutable response object with properties the same as the `response-ready` event. This event is intended to the request-panel only to report final response after applying any transformation on the response at `response-ready` event.
Because browser can't guarantee event handlers execution order this shouldn't be done in the `response-ready` event or otherwise this would influence the performance (the response panel would compute the response each time the object change).

## Styling

`<request-panel>` provides the following custom properties and mixins for styling:

Custom property|Description|Default
---------- | ------------------ | ------
`--request-panel`|Mixin applied to the element|`{}`
`--request-panel-main-content` | Mixin applied to the container for the request and the resposnse panels | `{}`
`--request-panel-progress-color` | Color of the progress bar that indicate loading state | `#00A2DF`
`--request-panel-progress` | Mixin applied to the progress bar | `{}`
`--request-panel-status-bar` | Mixin applied to the status bar | `{}`
`--request-panel-status-bar-left` | Left position of the status bar. | `0`

@group UI Elements
@element request-panel
@demo demo/index.html
-->
<dom-module id="request-panel">
  <template>
    <style>
     :host {
      @apply --layout-vertical;
      @apply --request-panel;
    }

    .data-area {
      @apply --layout-flex;
      padding: 0px 24px 24px 24px;
      overflow: auto;

      @apply --request-panel-main-content;
    }

    paper-progress {
      width: 100%;
      --paper-progress-active-color: var(--request-panel-progress-color, #00A2DF);

      @apply --request-panel-progress;
    }

    arc-status-bar {
      left: var(--request-panel-status-bar-left, 0);
      @apply --request-panel-status-bar;
    }

    .dirty {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background-color: var(--request-panel-dirty-color, #FF8A65);
    }

    .save-action {
      color: var(--request-panel-save-button-color, rgba(0, 0, 0, 0.54));
    }
    </style>
    <div class="data-area">
      <request-editor
        loading-request="[[loading]]"
        headers="{{request.headers}}"
        method="{{request.method}}"
        payload="{{request.payload}}"
        url="{{request.url}}"
        xhr-extension="[[xhrExtension]]"></request-editor>
      <template is="dom-if" if="[[loading]]">
        <paper-progress indeterminate></paper-progress>
      </template>
      <template is="dom-if" if="[[hasResponse]]">
        <response-view
          request="[[transportRequest]]"
          response="[[response]]"
          response-error="[[responseError]]"
          is-xhr="[[responseIsXhr]]"
          loading-time="{{loadingTime}}"
          redirects="[[redirects]]"
          redirect-timings="[[redirectTimings]]"
          response-timings="[[timings]]"
          sent-http-message="[[sourceMessage]]"></response-view>
      </template>
    </div>
    <arc-status-bar>
      <template is="dom-if" if="[[!noSave]]">
        <span prefix>
          <paper-icon-button class="save-action" icon="arc:save" on-tap="_saveRequest"></paper-icon-button>
          <paper-tooltip animation-delay="200" position="top" offset="0">Save this request object</paper-tooltip>
        </span>
        <template is="dom-if" if="[[isDirty]]">
          <span prefix>
            <span class="dirty" on-tap=""></span>
            <paper-tooltip animation-delay="200" position="top" offset="0">Changes in the request object detected</paper-tooltip>
          </span>
        </template>
      </template>
    </arc-status-bar>
    <paper-toast id="errorToast"></paper-toast>
    <paper-toast id="cancelToast"></paper-toast>
    <uuid-generator id="uuid"></uuid-generator>
    <variables-evaluator id="eval" no-before-request></variables-evaluator>
  </template>
  <script>
  Polymer({
    is: 'request-panel',

    behaviors: [ArcBehaviors.EventsTargetBehavior],

    /**
     * Before sending the request the `before-request` custom event is fired.
     * The event contains the `promises` array on the detail object where all
     * promises should be kept. Handlers can modify any part of the request
     * message.
     *
     * This event is cancellable. If the event has been cancelled by any of the
     * listeners then the request fails. Handlers may set a reason property on
     * the event's detail object to display a reason to the user.
     *
     * The handler have a timeout set from the `handlers-timeout` attribute
     * of the element to complete any scheduled tasks. If a handler requires
     * more time to execute (eg. request debugger) it should set a `timeout`
     * property on the Promise object. It is a non-normative property for
     * this object but it will help control the workflow properly. The request
     * will be fired after the number of milliseconds of the highest timeout
     * value. If 0 is set then the request will be halted until
     * `continue-request` event is fired.
     *
     * @event before-request
     * @param {String} url Request URL.
     * @param {String} headers Headers to be send.
     * @param {String} payload Message body if the request can carry a body.
     * GET and HEAD request will ignore this property.
     * @param {String} method HTTP method.
     * @param {Array} promises An array where promises must be added
     * @param {String} reason The reason of cancelation. Must be set by the
     * handler.
     * @param {?Object} auth An authorization data that will be passed to the
     * transport library (`socket-fetch`)
     */

    /**
     * A non-cancelable, immutable request object.
     * This event is meant to be handled by the transport library that is
     * attached to the DOM and handles the event.
     *
     * @event transport-request
     * @param {String} url Request URL.
     * @param {String} headers Headers to be send.
     * @param {String} payload Message body if the request can carry a body.
     * GET and HEAD request will ignore this property.
     * @param {String} method HTTP method.
     * @param {?Object} auth An authorization data that will be passed to the
     * transport library (`socket-fetch`)
     */
    /**
     * Fired when the save action has been requested in the UI.
     * This event is cancelable.
     *
     * @event request-save-state
     */
    properties: {
      /**
       * The request object with current request editor state.
       * It contains the following properties:
       * - headers {String}
       * - method {String}
       * - url {String}
       * - payload {String|FormData|File}
       *
       * To listen for a change to this object use `request-data-changed`
       * custom ebent fired from the `request-editor` element.
       */
      request: Object,
      /**
       * Number of milliseconds after which the `before-request` event handlers
       * will be cancelled and the request continue without waiting for the
       * result. When set to `0`, `null`, `undefined` or `false` the timeoout
       * is not applied and the element waits with the request until
       * `continue-request` event is fired.
       */
      handlersTimeout: {
        type: Number,
        value: 2000
      },
      /**
       * Computed value. If true then the request is loading.
       * This resets each time the request status changes.
       */
      loading: Boolean,
      /**
       * Current before-request handlers timeout ID
       */
      _currentTimeout: Number,
      /**
       * If set the element listens for the `continue-request` event and
       * sends the request if it wasn't already.
       */
      _awaitingContinue: Boolean,
      /**
       * Set to `true` if the cancel request event has been fired.
       */
      _cancelled: Boolean,
      /**
       * Created by the transport `Request` object as defined in the Fetch
       * API spec.
       */
      transportRequest: {
        type: Request,
        notify: true,
        readOnly: true
      },
      /**
       * Created by the transport the `Response` object as defined in the
       * Fetch API spec.
       */
      response: {
        type: Response,
        notify: true,
        readOnly: true
      },
      // True if the response is made by the Fetch / XHR api.
      responseIsXhr: {
        type: Boolean,
        notify: true,
        readOnly: true
      },
      /**
       * An error object associated with the response when error.
       */
      responseError: {
        type: Object,
        notify: true,
        readOnly: true
      },
      // Computed value, true, when the response object is set.
      hasResponse: {
        type: Boolean,
        computed: '_computeHasResponse(response)'
      },
      // Response full loading time.
      loadingTime: {
        type: Number,
        notify: true,
        readOnly: true
      },
      /**
       * If the transport method is able to collect detailed information about request timings
       * then this value will be set. It's the `timings` property from the HAR 1.2 spec.
       */
      timings: {
        type: Object,
        notify: true,
        readOnly: true
      },
      /**
       * If the transport method is able to collect detailed information about redirects timings
       * then this value will be set. It's a list of `timings` property from the HAR 1.2 spec.
       */
      redirectTimings: {
        type: Array,
        notify: true,
        readOnly: true
      },
      /**
       * It will be set if the transport method can generate information about redirections.
       */
      redirects: {
        type: Array,
        notify: true,
        readOnly: true
      },
      /**
       * Http message sent to the server.
       *
       * This information should be available only in case of advanced HTTP transport.
       */
      sourceMessage: {
        type: String,
        notify: true,
        readOnly: true
      },
      /**
       * Set to true if current request has timed out in the `before-request`
       * event handlers. The request will continue without without waiting for
       * the event handlers anymore.
       */
      beforeTimedOut: {
        type: Boolean,
        readOnly: true
      },
      /**
       * If set then it renders an option in request context menu to
       * toggle to XHR request via the extension. This information is passed
       * to the request editor element.
       *
       * It's only relevant to ARC Chrome app.
       */
      xhrExtension: Boolean,
      /**
       * A flag that determines if the request object have changed since it has
       * been loaded into the panel.
       * It is only set if request has type set.
       * This should be reset by the application when the request object is saved.
       */
      isDirty: {
        type: Boolean,
        notify: true
      },
      /**
       * If set then "save request" controlls are not rendered.
       */
      noSave: {
        type: Boolean,
        value: false
      }
    },

    listeners: {
      'send-request': '_sendRequestHandler',
      'abort-request': '_abortRequestHandler',
      'request-clear-state': '_reset'
    },

    observers: [
      '_updateDirtyState(request.*)'
    ],

    _attachListeners: function(node) {
      this.listen(node, 'continue-request', '_continueRequestHandler');
      this.listen(node, 'report-response', '_reportRequestHandler');
      this.listen(node, 'resend-auth-request', '_resend');
    },

    _detachListeners: function(node) {
      this.unlisten(node, 'continue-request', '_continueRequestHandler');
      this.unlisten(node, 'report-response', '_reportRequestHandler');
      this.unlisten(node, 'resend-auth-request', '_resend');
    },

    ready: function() {
      if (!this.request) {
        this.request = {};
      }
    },

    _sendRequestHandler: function(e) {
      e.preventDefault();
      e.stopPropagation();
      this.send();
    },

    _abortRequestHandler: function() {
      this._cancelled = true;
      this._reportCancelation();
    },
    /**
     * Sends current request
     * @return {Promise} A promise resolved when the `before-request` custom
     * event is dispatched.
     */
    send: function() {
      var request = this._prepareEventRequest();
      return this._beforeProcessVariables(request);
    },
    /**
     * Before the request object can be sent to any `before-request` handler
     * it must be first evaluated by variables evaluator. It is the only way to
     * ensure that the handler will receive actuall request data.
     */
    _beforeProcessVariables: function(request) {
      return new Promise((resolve, reject) => {
        this.cache = undefined;
        this.context = undefined;
        this.$.eval._processBeforeRequest(request, resolve, reject);
      })
      .then(request => {
        this._beforeRequest(request);
      })
      .catch(() => {
        this._beforeRequest(request);
      });
    },

    _reset: function() {
      this._awaitingContinue = false;
      this._beforePromisesResolved = true;
      this._requestCopy = undefined;
      this._cancelled = false;
      this.loading = false;
      this._setBeforeTimedOut(false);
      this.setResponseData();
    },
    /**
     * Handles the before request logic.
     * @param {Object} request The request object.
     */
    _beforeRequest: function(request) {
      this._reset();
      this.loading = true;
      var event = this.fire('before-request', request, {
        cancelable: true,
        composed: true
      });
      if (event.defaultPrevented) {
        return this._reportCancelation(event.detail.reason);
      }
      this._requestCopy = request;
      var p = event.detail.promises;
      if (p && p.length) {
        this._beforePromisesResolved = false;
        let timeout = this._computeHandlersTimeout(p);
        p = Promise.all(p);
        if (timeout > 0) {
          this._currentTimeout =
            window.setTimeout(this._onBeforeRequestTimeout.bind(this), timeout);
        } else {
          this._awaitingContinue = true;
        }
      } else {
        p = Promise.resolve();
      }
      p.then(() => {
        this._beforePromisesResolved = true;
        if (this.beforeTimedOut || this._cancelled) {
          return;
        }
        if (!this._awaitingContinue) {
          this._continueRequest(request);
        }
      })
      .catch(cause => {
        this.loading = false;
        this._reportError(cause);
        console.warn(cause);
      });
    },
    /**
     * Prepares a request object to be used to send it with the `before-request`
     * event. This is a "shallow" copy of the `request` property. It only creates
     * a copy of the primitive values of the object. If the `payload` is an
     * object (`FormData` or `File`) then it will be passed by reference instead
     * of copying the object.
     *
     * It adds `promises` property to the object that is required by the
     * `before-request` event.
     *
     * @return {Object} Copy of the `request` property.
     */
    _prepareEventRequest: function() {
      var request = this.request;
      var shallowCopy = Object.assign({}, request);
      this.lastRequestId = shallowCopy.id = this.$.uuid.generate();
      shallowCopy.promises = [];
      if (['GET', 'HEAD'].indexOf(request.method) !== -1) {
        delete shallowCopy.payload;
      }
      return shallowCopy;
    },
    /**
     * Computes timeout for the before-request event handlers.
     * It reads a `timeout` property from a promise. If set, it returns a highest
     * value for the timeout or default value defined in the `handlersTimeout`
     * property. If `handlersTimeout` is falsy or any timeout property equals
     * zero (`0`) then this function returns -1 meaning no timeout.
     *
     * @param {Array} promises Array of promises returned by the handlers.
     * @return {Number} -1 for no timeout or positive number of milliseconds
     * for the `before-request` event to be handled by all handlers.
     */
    _computeHandlersTimeout: function(promises) {
      var timeout = this.handlersTimeout;
      if (!timeout) {
        return -1;
      }
      if (!promises || !promises.length) {
        return timeout;
      }
      for (var i = 0, len = promises.length; i < len; i++) {
        if (promises[i].timeout !== undefined) {
          if (promises[i].timeout === 0) {
            return -1;
          }
          if (promises[i].timeout > timeout) {
            timeout = promises[i].timeout;
          }
        }
      }
      if (timeout === 0) {
        timeout = -1;
      }
      return timeout;
    },
    /**
     * Clears the before-request timeout timer.
     */
    _clearBeforeRequestTimeout: function() {
      if (this._currentTimeout) {
        window.clearTimeout(this._currentTimeout);
        this._currentTimeout = undefined;
      }
    },
    /**
     * Called when the `before-request` timeout fired.
     * It continues the request with current values in the `_requestCopy`
     * property that has been sent with the `before-request` event.
     */
    _onBeforeRequestTimeout: function() {
      this._currentTimeout = undefined;
      this._setBeforeTimedOut(true);
      console.warn('The before-request event handlers timed out.');
      this._continueRequest(this._requestCopy);
    },
    /**
     * A handler for the `continue-request` custom event.
     * If "continues" the request if all promises for the `before-request`
     * has been resolved.
     * It do nothing if current request doesn't expect this event to be handled
     * (no timeout set to 0).
     */
    _continueRequestHandler: function() {
      if (!this._awaitingContinue) {
        return;
      }
      if (!this._beforePromisesResolved) {
        this._awaitingContinue = false;
        return;
      }
      this._continueRequest(this._requestCopy);
    },
    /**
     * Called when before request block finished (whatever the output) and the
     * request can now be send to the transport library.
     *
     * @param {Object} request The request object
     */
    _continueRequest: function(request) {
      this._requestCopy = undefined;
      this._clearBeforeRequestTimeout();
      delete request.promises;
      delete request.reason;
      // Changes to the `_requestCopy` object won't affect sent object.
      // However changes made to FormData or File object of the payload property
      // or to the `auth` object will affect send object because those are
      // references to an object.
      var copy = this._prepareTransportObject(request);
      this.fire('transport-request', copy);
    },

    _reportError: function(cause) {
      this.loading = false;
      this._clearBeforeRequestTimeout();
      var message = cause && cause.message ? cause.message : 'An error occurred';
      var t = this.$.errorToast;
      t.text = message;
      t.opened = true;
    },
    /**
     * Opens the cancelation message toast
     * @param {?String} reason Message to display. Optional.
     */
    _reportCancelation: function(reason) {
      this.loading = false;
      reason = reason || 'The request has been canceled';
      var t = this.$.cancelToast;
      t.text = reason;
      t.opened = true;
    },
    /**
     * Creates an immutable request data object to be send to the transport
     * library.
     * @return {Object} Immutable request object.
     */
    _prepareTransportObject: function(request) {
      var configuration = {};
      Object.keys(request).forEach(key => {
        configuration[key] = {
          value: request[key],
          writable: false,
          enumerable: true
        };
      });
      return Object.create(Object.prototype, configuration);
    },
    /**
     * Handler for the `report-request` event.
     * Sets the response information to render.
     *
     * @param {CustomEvent} e Event fired by the transport library.
     */
    _reportRequestHandler: function(e) {
      this.setResponseData(e.detail);
    },
    /**
     * Sets the response data for the response panel.
     *
     * @param {?Object} obj Properties described in `response-ready` event.
     * Passing empty object or not setting the object resets the panel state.
     */
    setResponseData: function(obj) {
      if (obj && obj.id !== this.lastRequestId) {
        return;
      }
      this.loading = false;
      obj = obj || {};
      var isXhr = obj.isXhr === undefined ? true : obj.isXhr;
      this._setResponseIsXhr(isXhr);
      this._setResponse(obj.response);
      this._setResponseError(obj.error);
      this._setTransportRequest(obj.request);
      this._setLoadingTime(obj.loadingTime);
      this._setTimings(obj.timings);
      this._setRedirectTimings(obj.redirectTimings);
      this._setRedirects(obj.redirects);
      this._setSourceMessage(obj.sourceMessage);
    },

    // Computes if there is a reponse object.
    _computeHasResponse: function(response) {
      return !!response;
    },
    // Handler for the `resend-auth-request` event. Sends this request.
    _resend: function(e) {
      if (e.detail.id !== this.lastRequestId) {
        return;
      }
      this.send();
    },

    _updateDirtyState: function(record) {
      if (!record || !record.base) {
        this.isDirty = false;
        return;
      }
      if (record.path === 'request') {
        // new object has been set. Whatever it's type it is not dirty.
        this.isDirty = false;
        return;
      }
      var request = record.base;
      if (!request.type) {
        return;
      }
      if (request.type !== 'history') {
        this.isDirty = true;
      }
    },
    /**
     * Dispatches cancelable `request-save-state` custom event to indicate that
     * the save data action has been performed by the user.
     */
    _saveRequest: function() {
      this.fire('request-save-state', undefined, {
        cancelable: true
      });
    }
  });
  </script>
</dom-module>
